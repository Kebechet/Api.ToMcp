using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Api.ToMcp.Generator.Models;

namespace Api.ToMcp.Generator.Emitting
{
    internal static class ToolClassEmitter
    {
        public static string Emit(ActionInfoModel action, GeneratorConfigModel config)
        {
            var toolName = FormatToolName(action, config.Naming);
            var description = action.CustomDescription ?? action.XmlDocSummary ?? $"Invokes {action.ControllerName}.{action.Name}";

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.ComponentModel;");
            sb.AppendLine("using System.Text.Json;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using ModelContextProtocol.Server;");
            sb.AppendLine("using Api.ToMcp.Runtime;");
            sb.AppendLine();
            sb.AppendLine("namespace Api.ToMcp.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    [McpServerToolType]");
            sb.AppendLine($"    public static class {action.ToolClassName}");
            sb.AppendLine("    {");

            EmitToolMethod(sb, action, toolName, description);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void EmitToolMethod(
            StringBuilder sb,
            ActionInfoModel action,
            string toolName,
            string description)
        {
            var parameters = action.Parameters
                .Where(p => p.Source != ParameterSourceModel.Services)
                .ToList();

            sb.AppendLine($"        [McpServerTool(Name = \"{toolName}\")]");
            sb.AppendLine($"        [Description(\"{EscapeString(description)}\")]");
            sb.Append("        public static async Task<string> InvokeAsync(");
            sb.AppendLine();
            sb.AppendLine("            IMcpHttpInvoker invoker,");

            for (int i = 0; i < parameters.Count; i++)
            {
                var param = parameters[i];
                var paramDecl = FormatParameterDeclaration(param);
                var comma = i < parameters.Count - 1 ? "," : "";
                sb.AppendLine($"            {paramDecl}{comma}");
            }

            sb.AppendLine("        )");
            sb.AppendLine("        {");

            EmitRouteBuilding(sb, action, parameters);
            EmitHttpCall(sb, action, parameters);

            sb.AppendLine("        }");
        }

        private static void EmitRouteBuilding(
            StringBuilder sb,
            ActionInfoModel action,
            List<ParameterInfoModel> parameters)
        {
            var route = action.RouteTemplate;

            // Find route parameters (parameters that appear in the route template)
            // Need to check for both {name} and {name:constraint} patterns
            var routeParams = parameters.Where(p =>
                p.Source == ParameterSourceModel.Route ||
                (p.Source == ParameterSourceModel.Auto && RouteContainsParameter(route, p.Name))).ToList();

            foreach (var param in routeParams)
            {
                // Value types can't be null, so don't use null-conditional operator
                var toStringExpr = IsValueType(param.Type) && !param.IsNullable
                    ? $"{param.Name}.ToString()"
                    : $"{param.Name}?.ToString() ?? string.Empty";
                sb.AppendLine($"            var route{param.Name} = System.Uri.EscapeDataString({toStringExpr});");
            }

            sb.AppendLine($"            var route = $\"{ConvertRouteTemplate(route, routeParams)}\";");

            // Build query string
            var queryParams = parameters.Where(p =>
                p.Source == ParameterSourceModel.Query ||
                (p.Source == ParameterSourceModel.Auto &&
                 !RouteContainsParameter(route, p.Name) &&
                 action.HttpMethod == "GET" &&
                 !IsComplexType(p.Type))).ToList();

            if (queryParams.Any())
            {
                sb.AppendLine("            var queryParts = new System.Collections.Generic.List<string>();");
                foreach (var param in queryParams)
                {
                    if (param.IsNullable || param.HasDefaultValue)
                    {
                        sb.AppendLine($"            if ({param.Name} != null)");
                        sb.AppendLine($"                queryParts.Add($\"{param.Name}={{System.Uri.EscapeDataString({param.Name}.ToString()!)}}\");");
                    }
                    else
                    {
                        sb.AppendLine($"            queryParts.Add($\"{param.Name}={{System.Uri.EscapeDataString({param.Name}.ToString()!)}}\");");
                    }
                }
                sb.AppendLine("            if (queryParts.Count > 0)");
                sb.AppendLine("                route += \"?\" + string.Join(\"&\", queryParts);");
            }
        }

        private static void EmitHttpCall(
            StringBuilder sb,
            ActionInfoModel action,
            List<ParameterInfoModel> parameters)
        {
            var bodyParam = parameters.FirstOrDefault(p => p.Source == ParameterSourceModel.Body);

            if (action.HttpMethod == "GET")
            {
                sb.AppendLine("            var response = await invoker.GetAsync(route);");
            }
            else if (action.HttpMethod == "POST")
            {
                if (bodyParam != null)
                {
                    sb.AppendLine($"            var bodyJson = JsonSerializer.Serialize({bodyParam.Name});");
                    sb.AppendLine("            var response = await invoker.PostAsync(route, bodyJson);");
                }
                else
                {
                    sb.AppendLine("            var response = await invoker.PostAsync(route, null);");
                }
            }

            sb.AppendLine("            return response;");
        }

        public static string EmitRegistration(ImmutableArray<ActionInfoModel> actions)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("namespace Api.ToMcp.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public static class McpToolsInfo");
            sb.AppendLine("    {");
            sb.AppendLine("        public static readonly System.Type[] ToolTypes = new System.Type[]");
            sb.AppendLine("        {");

            foreach (var action in actions)
            {
                sb.AppendLine($"            typeof({action.ToolClassName}),");
            }

            sb.AppendLine("        };");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string FormatToolName(ActionInfoModel action, NamingConfigModel naming)
        {
            var customName = action.CustomToolName;
            if (!string.IsNullOrEmpty(customName))
                return customName!;

            var controller = action.ControllerName;
            var actionName = action.Name;

            if (naming.RemoveControllerSuffix && controller.EndsWith("Controller"))
                controller = controller.Substring(0, controller.Length - "Controller".Length);

            return naming.ToolNameFormat
                .Replace("{Controller}", controller)
                .Replace("{Action}", actionName);
        }

        private static string FormatParameterDeclaration(ParameterInfoModel param)
        {
            var type = param.Type;

            // Make type nullable if it has a default value but isn't already nullable
            if (param.HasDefaultValue && !param.IsNullable && !type.EndsWith("?"))
            {
                // For value types, make them nullable
                if (IsValueType(type))
                {
                    type += "?";
                }
            }

            var defaultPart = "";
            if (param.HasDefaultValue)
            {
                if (param.DefaultValue == null)
                {
                    defaultPart = " = null";
                }
                else if (param.DefaultValue is string s)
                {
                    defaultPart = $" = \"{s}\"";
                }
                else if (param.DefaultValue is bool b)
                {
                    defaultPart = $" = {(b ? "true" : "false")}";
                }
                else if (param.DefaultValue is char c)
                {
                    defaultPart = $" = '{c}'";
                }
                else
                {
                    defaultPart = $" = {param.DefaultValue}";
                }
            }
            else if (param.IsNullable)
            {
                defaultPart = " = null";
            }

            var descAttr = $"[Description(\"Parameter: {param.Name}\")] ";
            return $"{descAttr}{type} {param.Name}{defaultPart}";
        }

        private static bool RouteContainsParameter(string route, string paramName)
        {
            // Check for {name} or {name:constraint} or {name?} patterns
            var simplePattern = "{" + paramName + "}";
            var optionalPattern = "{" + paramName + "?}";
            var constraintPattern = "{" + paramName + ":";

            return route.Contains(simplePattern) ||
                   route.Contains(optionalPattern) ||
                   route.Contains(constraintPattern);
        }

        private static string ConvertRouteTemplate(string route, List<ParameterInfoModel> routeParams)
        {
            var result = route;
            foreach (var param in routeParams)
            {
                // Handle various route parameter formats using regex to catch any constraint
                // Pattern matches: {name}, {name?}, {name:constraint}, {name:constraint?}
                var pattern = @"\{" + param.Name + @"(:[^}]+)?\??\}";
                result = System.Text.RegularExpressions.Regex.Replace(
                    result,
                    pattern,
                    "{route" + param.Name + "}",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            }
            return result;
        }

        private static string EscapeString(string s)
        {
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", " ").Replace("\r", "");
        }

        private static bool IsValueType(string typeName)
        {
            var valueTypes = new[]
            {
                "int", "Int32", "System.Int32",
                "long", "Int64", "System.Int64",
                "short", "Int16", "System.Int16",
                "byte", "Byte", "System.Byte",
                "bool", "Boolean", "System.Boolean",
                "double", "Double", "System.Double",
                "float", "Single", "System.Single",
                "decimal", "Decimal", "System.Decimal",
                "char", "Char", "System.Char",
                "DateTime", "System.DateTime",
                "DateTimeOffset", "System.DateTimeOffset",
                "TimeSpan", "System.TimeSpan",
                "Guid", "System.Guid"
            };
            return valueTypes.Any(t => typeName == t || typeName.EndsWith("." + t));
        }

        private static bool IsComplexType(string typeName)
        {
            var primitives = new[]
            {
                "string", "String", "System.String",
                "int", "Int32", "System.Int32",
                "long", "Int64", "System.Int64",
                "short", "Int16", "System.Int16",
                "byte", "Byte", "System.Byte",
                "bool", "Boolean", "System.Boolean",
                "double", "Double", "System.Double",
                "float", "Single", "System.Single",
                "decimal", "Decimal", "System.Decimal",
                "char", "Char", "System.Char",
                "DateTime", "System.DateTime",
                "DateTimeOffset", "System.DateTimeOffset",
                "TimeSpan", "System.TimeSpan",
                "Guid", "System.Guid"
            };
            return !primitives.Any(t => typeName == t || typeName.EndsWith("." + t) || typeName.EndsWith("?"));
        }
    }
}

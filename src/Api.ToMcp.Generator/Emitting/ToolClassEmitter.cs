using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Api.ToMcp.Generator.Models;

namespace Api.ToMcp.Generator.Emitting
{
    internal static class ToolClassEmitter
    {
        public static string Emit(ActionInfoModel action, GeneratorConfigModel config, string? overrideClassName = null)
        {
            var toolName = FormatToolName(action, config.Naming);
            var className = overrideClassName ?? action.ToolClassName;
            var description = action.CustomDescription ?? action.XmlDocSummary ?? $"Invokes {action.ControllerName}.{action.Name}";

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.ComponentModel;");
            sb.AppendLine("using System.Text.Json;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using ModelContextProtocol.Server;");
            sb.AppendLine("using Api.ToMcp.Runtime;");
            sb.AppendLine("using Api.ToMcp.Abstractions.Scopes;");
            sb.AppendLine();
            sb.AppendLine("namespace Api.ToMcp.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    [McpServerToolType]");
            sb.AppendLine($"    public static class {className}");
            sb.AppendLine("    {");

            EmitToolMethod(sb, action, toolName, description);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void EmitToolMethod(
            StringBuilder sb,
            ActionInfoModel action,
            string toolName,
            string description)
        {
            var parameters = action.Parameters
                .Where(p => p.Source != ParameterSourceModel.Services)
                .ToList();

            sb.AppendLine($"        [McpServerTool(Name = \"{toolName}\")]");
            sb.AppendLine($"        [Description(\"{EscapeString(description)}\")]");
            sb.Append("        public static async Task<string> InvokeAsync(");
            sb.AppendLine();

            var invokerComma = parameters.Count > 0 ? "," : "";
            sb.AppendLine($"            IMcpHttpInvoker invoker{invokerComma}");

            for (int i = 0; i < parameters.Count; i++)
            {
                var param = parameters[i];
                var paramDecl = FormatParameterDeclaration(param);
                var comma = i < parameters.Count - 1 ? "," : "";
                sb.AppendLine($"            {paramDecl}{comma}");
            }

            sb.AppendLine("        )");
            sb.AppendLine("        {");

            EmitRouteBuilding(sb, action, parameters);
            EmitHttpCall(sb, action, parameters);

            sb.AppendLine("        }");
        }

        private static void EmitRouteBuilding(
            StringBuilder sb,
            ActionInfoModel action,
            List<ParameterInfoModel> parameters)
        {
            var route = action.RouteTemplate;

            // Extract all route placeholders from the template
            var placeholderRegex = new System.Text.RegularExpressions.Regex(@"\{(\w+)(:[^}]+)?\??\}");
            var matches = placeholderRegex.Matches(route);
            var routePlaceholders = matches.Cast<System.Text.RegularExpressions.Match>()
                .Select(m => m.Groups[1].Value)
                .Distinct()
                .ToList();

            // Build mapping from placeholder to source expression
            var placeholderSources = new Dictionary<string, (string expression, string type, bool isNullable, string varName)>();

            foreach (var placeholder in routePlaceholders)
            {
                // Check if direct parameter match (case-insensitive)
                var directParam = parameters.FirstOrDefault(p =>
                    string.Equals(p.Name, placeholder, StringComparison.OrdinalIgnoreCase));

                if (directParam != null)
                {
                    placeholderSources[placeholder] = (directParam.Name, directParam.Type, directParam.IsNullable, directParam.Name);
                }
                else
                {
                    // Check complex types (FromRoute or Body) for matching property
                    var complexParam = parameters.FirstOrDefault(p =>
                        (p.Source == ParameterSourceModel.Route || p.Source == ParameterSourceModel.Body) &&
                        IsComplexType(p.Type) &&
                        p.Properties.Any(prop => string.Equals(prop.Name, placeholder, StringComparison.OrdinalIgnoreCase)));

                    if (complexParam != null)
                    {
                        var matchingProperty = complexParam.Properties.First(prop =>
                            string.Equals(prop.Name, placeholder, StringComparison.OrdinalIgnoreCase));

                        var varName = $"{complexParam.Name}_{matchingProperty.Name}";
                        placeholderSources[placeholder] = (
                            $"{complexParam.Name}.{matchingProperty.Name}",
                            matchingProperty.Type,
                            matchingProperty.IsNullable,
                            varName);
                    }
                }
            }

            // Generate route variables
            foreach (var kvp in placeholderSources)
            {
                var placeholder = kvp.Key;
                var (expression, type, isNullable, varName) = kvp.Value;

                var toStringExpr = IsValueType(type) && !isNullable
                    ? $"{expression}.ToString()"
                    : $"{expression}?.ToString() ?? string.Empty";
                sb.AppendLine($"            var route{varName} = System.Uri.EscapeDataString({toStringExpr});");
            }

            // Convert route template - replace placeholders with generated variable names
            var convertedRoute = route;
            foreach (var kvp in placeholderSources)
            {
                var placeholder = kvp.Key;
                var varName = kvp.Value.varName;
                var pattern = @"\{" + placeholder + @"(:[^}]+)?\??\}";
                convertedRoute = System.Text.RegularExpressions.Regex.Replace(
                    convertedRoute, pattern, "{route" + varName + "}",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            }
            sb.AppendLine($"            var route = $\"{convertedRoute}\";");

            // Build query string
            var queryParams = parameters.Where(p =>
                p.Source == ParameterSourceModel.Query ||
                (p.Source == ParameterSourceModel.Auto &&
                 !RouteContainsParameter(route, p.Name) &&
                 action.HttpMethod == "GET" &&
                 !IsComplexType(p.Type))).ToList();

            if (queryParams.Any())
            {
                sb.AppendLine("            var queryParts = new System.Collections.Generic.List<string>();");
                foreach (var param in queryParams)
                {
                    if (param.IsNullable || param.HasDefaultValue)
                    {
                        sb.AppendLine($"            if ({param.Name} != null)");
                        sb.AppendLine($"                queryParts.Add($\"{param.Name}={{System.Uri.EscapeDataString({param.Name}.ToString()!)}}\");");
                    }
                    else
                    {
                        sb.AppendLine($"            queryParts.Add($\"{param.Name}={{System.Uri.EscapeDataString({param.Name}.ToString()!)}}\");");
                    }
                }
                sb.AppendLine("            if (queryParts.Count > 0)");
                sb.AppendLine("                route += \"?\" + string.Join(\"&\", queryParts);");
            }
        }

        private static void EmitHttpCall(
            StringBuilder sb,
            ActionInfoModel action,
            List<ParameterInfoModel> parameters)
        {
            var bodyParam = parameters.FirstOrDefault(p => p.Source == ParameterSourceModel.Body);
            var scopeName = action.RequiredScope.ToString();

            sb.AppendLine($"            await invoker.BeforeInvokeAsync(McpScope.{scopeName});");

            if (action.HttpMethod == "GET")
            {
                sb.AppendLine("            var response = await invoker.GetAsync(route);");
            }
            else if (action.HttpMethod == "POST")
            {
                if (bodyParam != null)
                {
                    sb.AppendLine($"            var bodyJson = JsonSerializer.Serialize({bodyParam.Name});");
                    sb.AppendLine("            var response = await invoker.PostAsync(route, bodyJson);");
                }
                else
                {
                    sb.AppendLine("            var response = await invoker.PostAsync(route, null);");
                }
            }
            else if (action.HttpMethod == "PUT")
            {
                if (bodyParam != null)
                {
                    sb.AppendLine($"            var bodyJson = JsonSerializer.Serialize({bodyParam.Name});");
                    sb.AppendLine("            var response = await invoker.PutAsync(route, bodyJson);");
                }
                else
                {
                    sb.AppendLine("            var response = await invoker.PutAsync(route, null);");
                }
            }
            else if (action.HttpMethod == "PATCH")
            {
                if (bodyParam != null)
                {
                    sb.AppendLine($"            var bodyJson = JsonSerializer.Serialize({bodyParam.Name});");
                    sb.AppendLine("            var response = await invoker.PatchAsync(route, bodyJson);");
                }
                else
                {
                    sb.AppendLine("            var response = await invoker.PatchAsync(route, null);");
                }
            }
            else if (action.HttpMethod == "DELETE")
            {
                sb.AppendLine("            var response = await invoker.DeleteAsync(route);");
            }

            sb.AppendLine("            return response;");
        }

        public static string EmitRegistration(ImmutableArray<ActionInfoModel> actions, Dictionary<string, int> seenToolClassNames)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("namespace Api.ToMcp.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    public static class McpToolsInfo");
            sb.AppendLine("    {");
            sb.AppendLine("        public static readonly System.Type[] ToolTypes = new System.Type[]");
            sb.AppendLine("        {");

            // Track counts to generate matching unique names
            var currentCounts = new Dictionary<string, int>(StringComparer.Ordinal);

            foreach (var action in actions)
            {
                var baseClassName = action.ToolClassName;
                string uniqueClassName;

                if (currentCounts.TryGetValue(baseClassName, out var count))
                {
                    currentCounts[baseClassName] = count + 1;
                    uniqueClassName = $"{baseClassName}_{count + 1}";
                }
                else
                {
                    currentCounts[baseClassName] = 1;
                    uniqueClassName = baseClassName;
                }

                sb.AppendLine($"            typeof({uniqueClassName}),");
            }

            sb.AppendLine("        };");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string FormatToolName(ActionInfoModel action, NamingConfigModel naming)
        {
            var customName = action.CustomToolName;
            if (!string.IsNullOrEmpty(customName))
                return customName!;

            var controller = action.ControllerName;
            var actionName = action.Name;

            if (naming.RemoveControllerSuffix && controller.EndsWith("Controller"))
                controller = controller.Substring(0, controller.Length - "Controller".Length);

            return naming.ToolNameFormat
                .Replace("{Controller}", controller)
                .Replace("{Action}", actionName);
        }

        private static string FormatParameterDeclaration(ParameterInfoModel param)
        {
            var type = param.Type;

            // Make type nullable if it has a default value but isn't already nullable
            if (param.HasDefaultValue && !param.IsNullable && !type.EndsWith("?"))
            {
                // For value types, make them nullable
                if (IsValueType(type))
                {
                    type += "?";
                }
            }

            var defaultPart = "";
            if (param.HasDefaultValue)
            {
                if (param.DefaultValue == null)
                {
                    defaultPart = " = null";
                }
                else if (param.DefaultValue is string s)
                {
                    defaultPart = $" = \"{s}\"";
                }
                else if (param.DefaultValue is bool b)
                {
                    defaultPart = $" = {(b ? "true" : "false")}";
                }
                else if (param.DefaultValue is char c)
                {
                    defaultPart = $" = '{c}'";
                }
                else
                {
                    defaultPart = $" = {param.DefaultValue}";
                }
            }
            else if (param.IsNullable)
            {
                defaultPart = " = null";
            }

            var descAttr = $"[Description(\"Parameter: {param.Name}\")] ";
            return $"{descAttr}{type} {param.Name}{defaultPart}";
        }

        internal static bool RouteContainsParameter(string route, string paramName)
        {
            // Check for {name} or {name:constraint} or {name?} patterns
            var simplePattern = "{" + paramName + "}";
            var optionalPattern = "{" + paramName + "?}";
            var constraintPattern = "{" + paramName + ":";

            return route.Contains(simplePattern) ||
                   route.Contains(optionalPattern) ||
                   route.Contains(constraintPattern);
        }

        internal static string ConvertRouteTemplate(string route, List<ParameterInfoModel> routeParams)
        {
            var result = route;
            foreach (var param in routeParams)
            {
                // Handle various route parameter formats using regex to catch any constraint
                // Pattern matches: {name}, {name?}, {name:constraint}, {name:constraint?}
                var pattern = @"\{" + param.Name + @"(:[^}]+)?\??\}";
                result = System.Text.RegularExpressions.Regex.Replace(
                    result,
                    pattern,
                    "{route" + param.Name + "}",
                    System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            }
            return result;
        }

        private static string EscapeString(string s)
        {
            return s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", " ").Replace("\r", "");
        }

        internal static bool IsValueType(string typeName)
        {
            var valueTypes = new[]
            {
                "int", "Int32", "System.Int32",
                "long", "Int64", "System.Int64",
                "short", "Int16", "System.Int16",
                "byte", "Byte", "System.Byte",
                "sbyte", "SByte", "System.SByte",
                "ushort", "UInt16", "System.UInt16",
                "uint", "UInt32", "System.UInt32",
                "ulong", "UInt64", "System.UInt64",
                "nint", "IntPtr", "System.IntPtr",
                "nuint", "UIntPtr", "System.UIntPtr",
                "bool", "Boolean", "System.Boolean",
                "double", "Double", "System.Double",
                "float", "Single", "System.Single",
                "decimal", "Decimal", "System.Decimal",
                "Half", "System.Half",
                "Int128", "System.Int128",
                "UInt128", "System.UInt128",
                "char", "Char", "System.Char",
                "DateTime", "System.DateTime",
                "DateTimeOffset", "System.DateTimeOffset",
                "TimeSpan", "System.TimeSpan",
                "Guid", "System.Guid",
                "DateOnly", "System.DateOnly",
                "TimeOnly", "System.TimeOnly"
            };
            return valueTypes.Any(t => typeName == t || typeName.EndsWith("." + t));
        }

        internal static bool IsComplexType(string typeName)
        {
            var primitives = new[]
            {
                "string", "String", "System.String",
                "int", "Int32", "System.Int32",
                "long", "Int64", "System.Int64",
                "short", "Int16", "System.Int16",
                "byte", "Byte", "System.Byte",
                "sbyte", "SByte", "System.SByte",
                "ushort", "UInt16", "System.UInt16",
                "uint", "UInt32", "System.UInt32",
                "ulong", "UInt64", "System.UInt64",
                "nint", "IntPtr", "System.IntPtr",
                "nuint", "UIntPtr", "System.UIntPtr",
                "bool", "Boolean", "System.Boolean",
                "double", "Double", "System.Double",
                "float", "Single", "System.Single",
                "decimal", "Decimal", "System.Decimal",
                "Half", "System.Half",
                "Int128", "System.Int128",
                "UInt128", "System.UInt128",
                "char", "Char", "System.Char",
                "DateTime", "System.DateTime",
                "DateTimeOffset", "System.DateTimeOffset",
                "TimeSpan", "System.TimeSpan",
                "Guid", "System.Guid",
                "DateOnly", "System.DateOnly",
                "TimeOnly", "System.TimeOnly"
            };
            return !primitives.Any(t => typeName == t || typeName.EndsWith("." + t) || typeName.EndsWith("?"));
        }
    }
}
